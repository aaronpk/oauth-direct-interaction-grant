



OAuth Working Group                                           A. Parecki
Internet-Draft                                                      Okta
Intended status: Standards Track                            P. Kasselman
Expires: 12 June 2023                                          Microsoft
                                                         9 December 2022


                   OAuth 2.0 Direct Interaction Grant
          draft-parecki-oauth-direct-interaction-grant-latest

Abstract

   This document extends the OAuth 2.0 Authorization Framework [RFC6749]
   with a new grant type, the "Direct Interaction Grant", which can be
   used by applications that want to control the user experience of the
   process of obtaining authorization from the user.

   In many cases, this can provide an entirely browserless experience
   suited for native applications, delegating to the browser in
   unexpected or error conditions.

   While a fully-delegated approach using the Authorization Code Grant
   is generally preferred, this draft provides a mechanism for the
   client to directly interact with the user.  This requires a high
   degree of trust between the authorization server and the client.  It
   SHOULD only be considered when there are usability concerns with a
   browser-based approach, such as for native mobile or desktop
   applications.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://aaronpk.github.io/oauth-direct-interaction-grant/draft-
   parecki-oauth-direct-interaction-grant.html.  Status information for
   this document may be found at https://datatracker.ietf.org/doc/draft-
   parecki-oauth-direct-interaction-grant/.

   Discussion of this document takes place on the OAuth Working Group
   mailing list (mailto:oauth@ietf.org), which is archived at
   https://oauth.net.  Subscribe at
   https://www.ietf.org/mailman/listinfo/oauth/.

   Source for this draft and an issue tracker can be found at
   https://github.com/aaronpk/oauth-direct-interaction-grant.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 12 June 2023.

Copyright Notice

   Copyright (c) 2022 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Usage and Applicability
     1.2.  Use Cases
       1.2.1.  Sign-up with verification
       1.2.2.  Register new authentication methods
       1.2.3.  Sign-in with first factor
       1.2.4.  Sign-in with additional factor
       1.2.5.  Discover supported authentication methods
       1.2.6.  Discover supported account recover authentication
               methods
       1.2.7.  Discover supported account recover authentication
               methods
       1.2.8.  Update an existing authentication method
       1.2.9.  Initiate browser-based interaction for certain
               scenarios
       1.2.10. Discovering custom user attributes
   2.  Conventions and Definitions
     2.1.  Terminology
   3.  Protocol Overview
   4.  Protocol
     4.1.  Client receives trigger for authentication
     4.2.  Client collects user identifier
     4.3.  Client initiates direct interaction request
     4.4.  Authorization Server returns challenge types
       4.4.1.  One-Time code
       4.4.2.  TOTP
       4.4.3.  Password
       4.4.4.  Push notification
       4.4.5.  Redirect
       4.4.6.  Combinations
       4.4.7.  Defining additional methods
     4.5.  Client requests an authentication challenge
     4.6.  Client provides authentication details
       4.6.1.  Token request
     4.7.  Checking for additional requirements
   5.  Refresh Token Grant
   6.  Security Considerations
     6.1.  Phishing
     6.2.  Native client and Authorisation Server trust relationship
     6.3.  Client Authentication
     6.4.  Leaking Information
     6.5.  Notification fatigue
   7.  IANA Considerations
     7.1.  OAuth Parameter Registration
     7.2.  OAuth URI Registration
     7.3.  OAuth Extensions Error Registration
     7.4.  Authorization Server Metadata
   8.  Normative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   TODO: Key points to address include problem description, the
   relationship to the step-up authentication spec (use of acr etc.),
   properties of the protocol (extensibility etc).

1.1.  Usage and Applicability

   TODO: Mention the trust prerequisites for this to be useful.
   Absolutely not allowed for third-party apps.  Designed for native
   apps, specifically first-party, when the AS and app are operated by
   the same entity, and the user understands them both as the same
   entity...

1.2.  Use Cases

   TODO: We may move these to the appendix, but outlining them in the
   document will also help guide developers to understand what they can
   (and cannot) expect to be able to to

1.2.1.  Sign-up with verification

   e.g. user provides e-mail, is sent a verification code, and then uses
   the verification code to prove they control the e-mail during sign-
   up/account creation.

1.2.2.  Register new authentication methods

   e.g. user selects password, provides phone for SMS codes, etc

1.2.3.  Sign-in with first factor

   e.g. username password

1.2.4.  Sign-in with additional factor

   e.g. user already signed in with one factor (username/password), but
   now need to "step-up" to second factor (e.g.  SMS code).

1.2.5.  Discover supported authentication methods

   e.g. developer can query the authorisation server to determine what
   authentication methods are supported.

1.2.6.  Discover supported account recover authentication methods

   e.g. developer can query the authorisation server to determine what
   authentication methods are used for account recovery if one of the
   methods are lost.

1.2.7.  Discover supported account recover authentication methods

   e.g. developer can query the authorisation server to determine what
   authentication methods are used for account recovery if one of the
   methods are lost.

1.2.8.  Update an existing authentication method

   e.g. the authorisation server may require the user to update a
   password or provide a new phone number, key or alternative e-mail
   address if it believes the existing mechanism is no longer
   trustworthy.

1.2.9.  Initiate browser-based interaction for certain scenarios

   e.g. some scenarios don't benefit from a native implementation and
   may be more efficiently or securely implemented through the browser
   (e.g. error scenarios, password recovery, identity verification,
   social sign-in).

1.2.10.  Discovering custom user attributes

   e.g.  Ability to know mandatory and optional custom attributes
   configured on the authorisation server (can this be achieve through
   AS metadata instead of as part of the protocol)?

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.1.  Terminology

   This specification uses the terms "Access Token", "Authorization
   Code", "Authorization Endpoint", "Authorization Server" (AS),
   "Client", "Client Authentication", "Client Identifier", "Client
   Secret", "Grant Type", "Protected Resource", "Redirection URI",
   "Refresh Token", "Resource Owner", "Resource Server" (RS) and "Token
   Endpoint" defined by [RFC6749].

3.  Protocol Overview

   1.  The client receives a signal from resource server indicating that
       a step-up authentication is requried

   2.  The client prompts the user and collects their user identifier
       (e.g. email address)

   3.  The client sends the identifier to the AS, along with any hint it
       may have received about the authentication level required

   4.  The AS replies with the supported authentication mechanisms based
       on the user ID provided (should these be amr values?)

   5.  The client requests an authentication challenge from the AS (this
       is optional - only if the authentication method requires it)

   6.  The AS delivers a challenge to the user (e.g. one-time code via
       email, SMS, or a push notification in an app) (this is optional -
       only if it is a challenge response type authentiation method).

   7.  The client collects the necessary authentication details from the
       user and sends them back to the AS

   8.  The AS decides if additional requirements need to be met,
       repeating steps 3 through 6 as needed (the AS knows this due to
       the acr_value sent by the client initially)

   9.  The AS replies with the token response

4.  Protocol

4.1.  Client receives trigger for authentication

   TODO: The client may receive a trigger from the resource server to
   initiate an authentication, possibly with a hint from the resource
   provider in the form of an acr value, indicating it needs to initiate
   and authentications.

   TBD: May need to reference the existing step-up authentication draft
   instead

4.2.  Client collects user identifier

   TODO: User identifier can be an email, phone number, or username, at
   the discretion of the AS.

4.3.  Client initiates direct interaction request

   The client makes a request to the interaction request endpoint
   providing the client ID and user identifer hint in the request.

   POST /interaction
   Host: authorization-server.com
   Content-type: application/x-www-form-urlencoded

   &client_id=XXXXXXX
   &username=user@example.com
   &scope=contacts+openid+profile

4.4.  Authorization Server returns challenge types

   The AS returns an interaction code, as well as a list of challenge
   types supported.

   HTTP/1.1 403 Forbidden
   Content-type: application/json

   {
     "error": "...?",
     "interaction_code": "b135ac938e3e84",
     "challenge_type": [
       "password+totp", "email_otp", "redirect"
     ]
   }

4.4.1.  One-Time code

   *  email_otp

   *  sms_otp

   One-time codes sent via email or SMS

4.4.2.  TOTP

   *  totp

   TOTP codes generated by an authenticator app

4.4.3.  Password

   *  password

   Legacy password authentication

4.4.4.  Push notification

   *  push_notification

   A push notification delivered to a native application

4.4.5.  Redirect

   *  redirect

   In the case where the authorization server wishes to interact with
   the user itself, limiting the client's interaction with the user, it
   can return the redirect challenge type.  In this case, no
   interaction_code is returned.  Instead, the client is expected to
   initiate a traditional OAuth Authorization Code flow with PKCE
   according to [RFC6749] and [RFC7636].

   TODO: Instead of no interaction code, should this require the client
   include the interaction code in the authorization request so the AS
   can link it to an app-initiated session?  Alternatively, if we make
   the first request require a PKCE code challenge, we could require the
   same PKCE code challenge be used in the authorization request.  My
   preference here is to include the PKCE code verifier at the start of
   the protocol.  PKCE is well understood and re-using the interaction
   code to establish the link feels like we are overloading the
   interaction code.  Another option may be to add a session identifier
   (or return a session identifier as a unique parameter) for the
   redirect case.

   This can be used to:

   *  offer the client a fallback mechanism at the client's perogative
      (by returning the redirect type as the last item in the
      challenge_type list)

   *  force the client to use a browser-redirect-based flow (by
      returning only the redirect type)

   *  enable authentication with social providers or third party IdPs
      which require a browser flow

4.4.6.  Combinations

   The AS MAY combine challenge types by concatenating strings with a +,
   which indicates that all the combined types are required to complete
   the challenge.

   TODO: Does the absense of a '+' imply an OR?

4.4.7.  Defining additional methods

   Extensibility...

4.5.  Client requests an authentication challenge

   Optional.

   For methods that require the AS to deliver a code to the user, e.g.
   via email or SMS, the client needs to signal to the AS that it should
   deliver this code.  (Without this step, the AS may not know which of
   the available options the client will be communicating to the user,
   and may not want to send a code via both email and SMS.).  It SHOULD
   only allow one delivery mechanism at a time to minimise the risk of
   the challenge leaking.

   POST /challenge
   Host: authorization-server.com
   Content-type: application/x-www-form-urlencoded

   challenge_type=email_otp
   &interaction_code=b135ac938e3e84

   The authorization server sends a challenge code to the user via the
   selected platform.

   The authorization server responds with an authentication challenge
   code and other information such as timeouts.

   HTTP/1.1 200 OK
   Content-type: application/json

   {
     "challenge_type": "email_otp",
     "challenge_code": "a6f4463ad1d8e3f",
     "expires_in": 600,
     "interval": 5
   }

   *  challenge_type -

   *  challenge_code -

   *  expires_in - Optional

   *  interval - Optional

4.6.  Client provides authentication details

   The client prompts the user to enter the challenge.

   *  One-time code

   *  Password

   *  Out-of-band interaction

   Some methods such as acknowledging a push notification may not
   require the user to interact further with the client.  The client
   instead presents a screen to the user explaining that they should
   acknowledge the challenge on another device.

   TODO: How does the Authorisation Server signal to the client that the
   push notification succeeded on another device?

4.6.1.  Token request

   The client makes a request to the token endpoint with the grant_type
   value of urn:ietf:params:oauth:grant-type:direct, providing the
   information collected from the user as well as the previous
   interaction code and optional challenge code.

   POST /token

   Host: authorization-server.com
   Content-type: application/x-www-form-urlencoded

   grant_type=urn:ietf:params:oauth:grant-type:direct
   &client_id=XXXXXXX
   &interaction_code=b135ac938e3e84
   &challenge_code=a6f4463ad1d8e3f
   &challenge_value=512512

   *  challenge_value - The value that was sent to the user.  Should
      this be different depending on the challenge type?

   TODO: What happens if more than one code is requested?  Maybe make it
   so only one can be collected at a time?  It would be weird to ask the
   user to enter two codes at the same time anyway.  Not sure we should
   have a unique interaction code per token.  Should the interaction
   code cover all the interactions (i.e. all interactions are bundled up
   as one interaction).  Once all interactions are complete all tokens
   for which that interaction is good can be released?

4.7.  Checking for additional requirements

   If the initial set of information provided by the client is correct,
   the AS MAY choose to either respond immetiately with a successful
   token request (response?), or prompt the client with an additional
   challenge.

   For example, the AS could first require the client prompt the user
   for a one-time-code they received via email, and then in a second
   step, ask the client to prompt the user

5.  Refresh Token Grant

   TODO: Describe how the AS could return a challenge to the client on
   the normal refresh token request that tells the client they need to
   get the user to re-authenticate or provide an MFA token.

6.  Security Considerations

   TODO Security

6.1.  Phishing

   TODO: Describe the phishing risk this opens up.

6.2.  Native client and Authorisation Server trust relationship

   TODO: Emphasise the 'same owner' relationship between the native
   client and the authorisation server

6.3.  Client Authentication

   TODO: Describe the lack of client authentication possible because
   this is expected to be deployed by native apps.  Maybe mention
   alternatives to client authentication such as App Attestation, or
   using a risk engine to analyze other aspects of the request from the
   client.

6.4.  Leaking Information

   TODO: Attackers may be able to query the AS with user IDs to learn
   whether an identifier corresponds to an active account and which
   types of authentication a particular account has configured.  What
   mitigations needed here?  Possibly avoiding returning an error for
   unrecognized identifiers.

6.5.  Notification fatigue

   TODO: A client may be able to cause repeated notifications to any
   user given their user ID.  Mitigations - throttling

7.  IANA Considerations

7.1.  OAuth Parameter Registration

   TODO

7.2.  OAuth URI Registration

   This specification registers the following values in the IANA "OAuth
   URI" registry (IANA.OAuth.Parameters) established by [RFC6755].

   URN: `urn:ietf:params:oauth:grant-type:direct`
   Common Name: Direct Interaction Grant Type for OAuth 2.0
   Change Controller: IESG
   Specification Document:

7.3.  OAuth Extensions Error Registration

   This specification registers the following values in the IANA "OAuth
   Extensions Error Registry" registry (IANA.OAuth.Parameters)
   established by [RFC6749].

   Name: ...

7.4.  Authorization Server Metadata

   This specification defines two new endpoints at the authorization
   server.  TODO: Need to register these in the Authorization Server
   Metadata document too.

   *  interaction endpoint

   *  challenge endpoint

8.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              <https://www.rfc-editor.org/rfc/rfc6749>.

   [RFC6755]  Campbell, B. and H. Tschofenig, "An IETF URN Sub-Namespace
              for OAuth", RFC 6755, DOI 10.17487/RFC6755, October 2012,
              <https://www.rfc-editor.org/rfc/rfc6755>.

   [RFC7636]  Sakimura, N., Ed., Bradley, J., and N. Agarwal, "Proof Key
              for Code Exchange by OAuth Public Clients", RFC 7636,
              DOI 10.17487/RFC7636, September 2015,
              <https://www.rfc-editor.org/rfc/rfc7636>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Aaron Parecki
   Okta
   Email: aaron@parecki.com


   Pieter Kasselman
   Microsoft
   Email: pieter.kasselman@microsoft.com
