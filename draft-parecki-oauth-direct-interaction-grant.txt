



OAuth Working Group                                           A. Parecki
Internet-Draft                                                      Okta
Intended status: Standards Track                            P. Kasselman
Expires: 18 June 2023                                          Microsoft
                                                        15 December 2022


                   OAuth 2.0 Direct Interaction Grant
          draft-parecki-oauth-direct-interaction-grant-latest

Abstract

   This document extends the OAuth 2.0 Authorization Framework [RFC6749]
   with a new grant type, the "Direct Interaction Grant", which can be
   used by applications that want to control the user experience of the
   process of obtaining authorization from the user.

   In many cases, this can provide an entirely browserless experience
   suited for native applications, delegating to the browser in
   unexpected or error conditions.

   While a fully-delegated approach using the Authorization Code Grant
   is generally preferred, this draft provides a mechanism for the
   client to directly interact with the user.  This requires a high
   degree of trust between the authorization server and the client.  It
   SHOULD only be considered when there are usability concerns with a
   browser-based approach, such as for native mobile or desktop
   applications.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://aaronpk.github.io/oauth-direct-interaction-grant/draft-
   parecki-oauth-direct-interaction-grant.html.  Status information for
   this document may be found at https://datatracker.ietf.org/doc/draft-
   parecki-oauth-direct-interaction-grant/.

   Discussion of this document takes place on the OAuth Working Group
   mailing list (mailto:oauth@ietf.org), which is archived at
   https://oauth.net.  Subscribe at
   https://www.ietf.org/mailman/listinfo/oauth/.

   Source for this draft and an issue tracker can be found at
   https://github.com/aaronpk/oauth-direct-interaction-grant.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 18 June 2023.

Copyright Notice

   Copyright (c) 2022 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Usage and Applicability
     1.2.  Use Cases
       1.2.1.  Sign-up with verification
       1.2.2.  Register new authentication methods
       1.2.3.  Sign-in with first factor
       1.2.4.  Sign-in with additional factor
       1.2.5.  Discover supported authentication methods
       1.2.6.  Discover supported account recover authentication
               methods
       1.2.7.  Update an existing authentication method
       1.2.8.  Initiate browser-based interaction for certain
               scenarios
       1.2.9.  Discovering custom user attributes
       1.2.10. Provide different UX depending on a user's enrolled
               authenticators
   2.  Conventions and Definitions
     2.1.  Terminology
   3.  Protocol Overview
     3.1.  Example Flows
       3.1.1.  Password + MFA
       3.1.2.  Passwordless
       3.1.3.  Re-authenticating to an app a week later
     3.2.  Authorization Grants
       3.2.1.  One-Time Passwords (OTP)
       3.2.2.  Out-of-Band Authorization (OOB)
       3.2.3.  Recovery Code
   4.  Protocol Endpoints
   5.  Authorization Challenge Response
   6.  Authorization Challenge Endpoint
     6.1.  Authorization Challenge Request
     6.2.  Authorization Challenge Response
       6.2.1.  OTP Challenge
       6.2.2.  OOB Challenge
       6.2.3.  Recovery Code Challenge
     6.3.  User Interaction
       6.3.1.  OTP Challenge Interaction
       6.3.2.  OOB Challenge Interaction
       6.3.3.  Recovery Code Challenge Interaction
   7.  Token Request Grant Types
     7.1.  OTP Grant
     7.2.  OOB Grant
       7.2.1.  Token Error Response
     7.3.  Recovery Code Grant
       7.3.1.  Access Token Response
   8.  Examples
     8.1.  Client receives trigger for authentication
     8.2.  Client collects user identifier
     8.3.  Client initiates direct interaction request
     8.4.  Authorization Server returns challenge types
       8.4.1.  One-Time code
       8.4.2.  TOTP
       8.4.3.  Password
       8.4.4.  Push notification
       8.4.5.  Redirect
       8.4.6.  Combinations
       8.4.7.  Defining additional methods
     8.5.  Client requests an authentication challenge
     8.6.  Client provides authentication details
       8.6.1.  Token request
     8.7.  Checking for additional requirements
   9.  Refresh Token Grant
   10. Security Considerations
     10.1.  Phishing
     10.2.  Native client and Authorisation Server trust relationship
     10.3.  Client Authentication
     10.4.  Leaking Information
     10.5.  Notification fatigue
   11. IANA Considerations
     11.1.  OAuth Parameter Registration
     11.2.  OAuth URI Registration
     11.3.  OAuth Extensions Error Registration
     11.4.  Authorization Server Metadata
   12. References
     12.1.  Normative References
     12.2.  Informative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   TODO: Key points to address include problem description, the
   relationship to the step-up authentication spec (use of acr etc.),
   properties of the protocol (extensibility etc).

1.1.  Usage and Applicability

   TODO: Mention the trust prerequisites for this to be useful.
   Absolutely not allowed for third-party apps.  Designed for native
   apps, specifically first-party, when the AS and app are operated by
   the same entity, and the user understands them both as the same
   entity...

1.2.  Use Cases

   TODO: We may move these to the appendix, but outlining them in the
   document will also help guide developers to understand what they can
   (and cannot) expect to be able to do.

   TODO: Registration flows may need to be a separate document.

1.2.1.  Sign-up with verification

   e.g. user provides e-mail, is sent a verification code, and then uses
   the verification code to prove they control the e-mail during sign-
   up/account creation.

1.2.2.  Register new authentication methods

   e.g. user selects password, provides phone for SMS codes, etc

1.2.3.  Sign-in with first factor

   e.g. username password

1.2.4.  Sign-in with additional factor

   e.g. user already signed in with one factor (username/password), but
   now need to "step-up" to second factor (e.g.  SMS code).

1.2.5.  Discover supported authentication methods

   e.g. developer can query the authorisation server to determine what
   authentication methods are supported.

1.2.6.  Discover supported account recover authentication methods

   e.g. developer can query the authorisation server to determine what
   authentication methods are used for account recovery if one of the
   methods are lost.

1.2.7.  Update an existing authentication method

   e.g. the authorisation server may require the user to update a
   password or provide a new phone number, key or alternative e-mail
   address if it believes the existing mechanism is no longer
   trustworthy.

1.2.8.  Initiate browser-based interaction for certain scenarios

   e.g. some scenarios don't benefit from a native implementation and
   may be more efficiently or securely implemented through the browser
   (e.g. error scenarios, password recovery, identity verification,
   social sign-in).

1.2.9.  Discovering custom user attributes

   e.g.  Ability to know mandatory and optional custom attributes
   configured on the authorisation server (can this be achieve through
   AS metadata instead of as part of the protocol)?

1.2.10.  Provide different UX depending on a user's enrolled
         authenticators

   An AS may support multiple different authenticators, and a user may
   have set up only one.  A client will not know which a user has set up
   ahead of time.  The AS needs to drive the UI in the client login
   process depending on the configuration of the user account.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.1.  Terminology

   This specification uses the terms "Access Token", "Authorization
   Code", "Authorization Endpoint", "Authorization Server" (AS),
   "Client", "Client Authentication", "Client Identifier", "Client
   Secret", "Grant Type", "Protected Resource", "Redirection URI",
   "Refresh Token", "Resource Owner", "Resource Server" (RS) and "Token
   Endpoint" defined by [RFC6749].

   TODO: Replace RFC6749 references with OAuth 2.1

3.  Protocol Overview

   1.  The client prompts the user and collects their user identifier
       (e.g. email address)

   2.  The client sends the user identifier to the AS, along with any
       hint it may have received about the authentication level required

   3.  The AS replies with the authentication mechanism required based
       on the user ID provided (should these be amr values?)

   4.  The client requests an authentication challenge from the AS (this
       is optional - only if the authentication method requires it)

   5.  The AS delivers a challenge to the user (e.g. one-time code via
       email, SMS, or a push notification in an app) (this is optional -
       only if it is a challenge response type authentiation method).

   6.  The client collects the necessary authentication details from the
       user and sends them back to the AS

   7.  The AS decides if additional requirements need to be met,
       repeating steps 3 through 6 as needed (the AS knows this due to
       the acr_value sent by the client initially, or from its own
       requirements)

   8.  The AS replies with the token response

3.1.  Example Flows

   TODO: Move these to an appendix

3.1.1.  Password + MFA

   *  User enters username and password (/initiate login_hint=
      password=)

   *  AS responds with mfa_required

   *  Client initiates MFA challenge (authorization challenge endpoint)

   *  AS responds with details of MFA challenge

   *  Client collects MFA from user (OTP, SMS code, etc)

   *  Client makes token request (new mfa:otp/mfa:oob grant type)

3.1.2.  Passwordless

   *  Client collects username and OTP from user

   *  Client makes token request (new otp grant type)

3.1.3.  Re-authenticating to an app a week later

   *  You log in to an app (in any way, redirect flow or direct)

   *  App gets short lived access token and long lived refresh token

   *  A week later, the user launches the app, access token is expired

   *  App uses the refresh token, gets back an mfa_required error

   *  App prompts and collects MFA from user (OTP or OOB)

   *  App submits token request with grant_type=mfa_otp and mfa_token
      (which was already associated with the refresh token)

3.2.  Authorization Grants

3.2.1.  One-Time Passwords (OTP)

   The one-time password (OTP) credentials can be used as an
   authorization grant to obtain an access token.  An OTP is generated
   by a hardware device or a software application installed on a device
   such as a mobile phone.  These devices have an embedded secret which
   used as a seed for generating OTPs.  An OTP is single-use and proves
   control of the device.

   When used in addition to another grant type (such as resource owner
   password credentials), one-time password credentials add an
   additional factor of authentication.

   Even though this grant type requires direct client access to the
   resource owner credentials, the resource owner credentials are used
   for a single request and are exchanged for an access token.
   Furthermore, the single-use nature of an OTP limits the impact of
   exposing a long-term password alone to the client when the resulting
   access token or refresh token are also short-lived.

   OTP methods include:

   *  Code generators such as Google Authenticator

3.2.2.  Out-of-Band Authorization (OOB)

   The out-of-band (OOB) authorization grant allows authorization to be
   obtained via a secondary channel.  Once authorized, the grant can be
   used to obtain an access token.  Use of a secondary channel supports
   several use cases.

   The out-of-band authorization grant can be used with an out-of-band
   authenticator to add an additional factor of authentication.  An out-
   of-band authenticator is a physical device that is uniquely
   addressable and can communicate with the authorization server over a
   secondary channel.  Common examples would be a mobile phone using SMS
   as a secondary channel, or a software application installed on a
   device using push notifications as a secondary channel.

   The out-of-band authorization grant can also facilitate more complex
   authorization processes.  For example, out-of-band authorization can
   be used to perform multi-party authorization, in which two or more
   resource owners are needed in order to grant access.

   OOB methods include:

   *  One-time codes sent via email and SMS

   *  Display a code on the primary device, enter it on the secondary
      device (e.g.  OAuth Device Flow)

   *  Acknowledge a push notification on a secondary device

   *  Compare the codes displayed on two devices

3.2.3.  Recovery Code

   The recovery code is numeric or character string from a set of
   secrets shared between the resource owner and the authorization
   server.  These secrets are typically used by the resource owner in
   the event another authenticator is lost or malfunctions.

4.  Protocol Endpoints

   *  Token endpoint

      -  This specification defines new grant types and new error
         responses

      -  Adds device_secret in token response

      -  Note: Passwords are never sent to the token endpoint

   *  Authorization challenge endpoint

      -  A client requests an authorization challenge (e.g. send a user
         an SMS code), which it can later use as an authorization grant

   *  Initiate login endpoint

      -  A client initiates a login flow

      -  With or without information collected from the user (e.g.
         password)

      -  May contain a device_secret

      -  Returns an mfa_token

   Not every authorization grant type utilizes both endpoints.
   Extension grant types MAY define additional endpoints as needed.

   The token endpoint is used by the client to obtain an access token by
   presenting its authorization grant or refresh token, as described in
   Section 3.2 of OAuth 2.0 [RFC6749].

   This specification adds additional grant types used at the token
   endpoint, as well as extends the token endpoint response to allow the
   authorization server to indicate that further authentication of the
   user is required.

   Extension Grant Types

   *  grant_type=urn:ietf:params:oauth:grant-type:mfa-otp

   *  grant_type=urn:ietf:params:oauth:grant-type:mfa-oob

   *  grant_type=urn:ietf:params:oauth:grant-type:mfa-recovery-code

   *  grant_type=urn:ietf:params:oauth:grant-type:otp

   *  grant_type=urn:ietf:params:oauth:grant-type:oob

5.  Authorization Challenge Response

   Upon any request to the token endpoint, the authorization server can
   respond with an authorization challenge instead of a successful
   access token response.

   An authorization challenge error response is a particular type of
   error response as defined in Section 5.2 of OAuth 2.0 [RFC6749] where
   the error code is set to the following value:

   "mfa_required":  The authorization grant is insufficiently
      authorized, but another access token request MAY succeed if an
      additional authorization grant is presented.

   In addition to the response parameters defined in Section 5.2 of
   OAuth 2.0 [RFC6749], the following parameters MUST be included in the
   response when the error code is set to mfa_required:

   "mfa_token":  MFA token value associated with the ongoing
      authorization session.

   For example:

   HTTP/1.1 403 Forbidden
   Content-Type: application/json;charset=UTF-8
   Cache-Control: no-store

   {
     "error": "mfa_required",
     "mfa_token": "uY29tL2F1dGhlbnRpY"
   }

6.  Authorization Challenge Endpoint

   The authorization challenge endpoint is used by the client to obtain
   an authorization challenge by presenting an MFA token.

   Use of the authorization challenge endpoint is OPTIONAL; if a client
   knows of a suitable authenticator through an out-of-band mechanism,
   it can obtain a strong authorization grant directly.

6.1.  Authorization Challenge Request

   The client makes a request to the authorization challenge endpoint by
   adding the following parameters using the "application/x-www-form-
   urlencoded" format with a character encoding of UTF-8 in the HTTP
   request body:

   "mfa_token":  REQUIRED.  The MFA token received from the
      authorization server in the authorization challenge error
      response.

   "challenge_type":  OPTIONAL.  List of authorization challenge type
      strings that the client supports, expressed as a list of space-
      delimited, case- insensitive strings.

   "authenticator_id":  OPTIONAL.  The identifier of the authenticator
      to challenge.  The authorization server MUST ensure that the
      authenticator is associated with the resource owner.

   "client_id":  REQUIRED, if the client is not authenticating with the
      authorization server as described in Section 3.2.1 of OAuth 2.0
      [RFC6749].

   For example, the client makes the following HTTP request:

   POST /challenge HTTP/1.1
   Host: server.example.com
   Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
   Content-Type: application/x-www-form-urlencoded

   mfa_token=uY29tL2F1dGhlbnRpY&challenge_type=otp%20oob

   The authorization server MUST:

   *  require client authentication for confidential clients or for any
      client that was issued client credentials (or with other
      authentication requirements),

   *  authenticate the client if client authentication is included,

   *  ensure that the MFA token was issued to the authenticated
      confidential client, or if the client is public, ensure that the
      token was issued to the client_id in the request,

   *  verify that the MFA token is valid, and

   *  restore the authorization session based on the state referenced by
      or encoded into the MFA token.

6.2.  Authorization Challenge Response

   If the authorization challenge request is valid and authorized, the
   authorization server selects an authorization challenge, the response
   to which would satisfy the authorization session, and constructs the
   response by adding the following parameters to the entity-body of the
   HTTP response using the application/json format [RFC8259] with a 200
   (OK) status code:

   "challenge_type":  REQUIRED.  The type of the authorization challenge
      issued.  Value is case insensitive.

   All additional parameters are specified by the authorization
   challenge type.  This document defines the otp type, the oob type,
   and the recovery-code type.

   For example:

   HTTP/1.1 200 OK
   Content-Type: application/json;charset=UTF-8
   Cache-Control: no-store

   {
     "challenge_type": "otp"
   }

   If the authorization challenge request failed, the authorization
   server responds with an error response as described in Section 5.2 of
   OAuth 2.0 [RFC6749].

   In addition to the error codes defined in Section 5.2 of OAuth 2.0
   [RFC6749], the following error codes are specified for use in
   authorization challenge endpoint responses:

   "invalid_authenticator":  The requested authenticator does not exist
      or is not associated with the resource owner.

   "expired_token":  The provided MFA token is invalid, expired,
      revoked, or was issued to another client.  The client MAY initiate
      a new authorization session.

   "unsupported_challenge_type":  The challenge types supported by the
      client are not supported by the authorization server or not
      available to the resource owner.

   "association_required":  The resource owner is not associated with
      any authenticator.  The authorization session MAY be continued by
      completing authenticator association.

   "server_error":  The authorization server encountered an unexpected
      condition that prevented it from fulfilling the request.

   "bad_gateway":  The authorization server received an invalid response
      from an upstream server it accessed in attempting to fulfull the
      request.  This typically occurs when challenging an OOB
      authenticator and the gateway is down, for example SMS.

6.2.1.  OTP Challenge

   If the authorization server requires an OTP credential as an
   additional authorization grant, it responds with an OTP authorization
   challenge type containing the following parameters:

   "challenge_type":  REQUIRED.  Value MUST be set to otp.

   No additional parameters are specified for the OTP authorization
   challenge type.

   For example:

   HTTP/1.1 200 OK
   Content-Type: application/json;charset=UTF-8
   Cache-Control: no-store

   {
       "challenge_type": "otp"
   }

6.2.2.  OOB Challenge

   If the authorization server requires out-of-band authorization as an
   additional authorization grant, it generates a unique out-of-band
   transaction code that is valid for a limited time.  It then initiates
   an out-of-band authorization operation, the details of which are out
   of scope for this specification.  It then responds with an OOB
   authorization challenge type containing the following parameters:

   "challenge_type":  REQUIRED.  Value MUST be set to "oob".

   "oob_code":  REQUIRED.  The out-of-band transaction code.  The out-
      of-band transaction code MUST expire shortly after it is issued to
      mitigate the risk of leaks.  A maximum out-of-band transaction
      code lifetime of 10 minutes is RECOMMENDED.  TODO: Determine
      whether this is required or what benefit it provides if any.

   "binding_code":  OPTIONAL.  The end-user verification code used to
      bind the authorization operation on the secondary channel with the
      primary channel.  REQUIRED, if the value of "binding_method" is
      set to "transfer" or "compare".

   "binding_method":  OPTIONAL.  The method used to bind the
      authorization operation on the secondary channel with the primary
      channel.  If no value is provided, clients MUST use "none" as the
      default.  Values defined by this specification are:

      "prompt":
      :  The end user should be prompted to enter a code received during
         out-of-band authorization via the secondary channel into the
         client.  For example, the end user receives a code on their
         mobile phone (typically a 6-digit code) and types it into the
         client.

      "transfer":
      :  The client displays or otherwise communicates the
         "binding_code" to the end user and instructs them to enter it
         into or otherwise transfer it to the secondary channel.  For
         example, the end user may view the "binding_code" on the client
         and either type it into an app on their mobile phone or use a
         QR code to effect the transfer.

      "compare":
      :  The client displays the "binding_code" to the end user and
         instructs them to compare it to the code received during out-
         of-band authorization before confirming authorization via the
         secondary channel.

      "none":
      :  No binding is performed between the client on the primary
         channel and the out-of-band authorization operation via the
         secondary channel.

   "expires_in":  OPTIONAL.  The lifetime in seconds of the oob_code.

   "interval":  OPTIONAL.  The minimum amount of time in seconds that
      the client SHOULD wait between polling requests to the token
      endpoint.  If no value is provided, clients MUST use 5 as the
      default.

   For example:

   HTTP/1.1 200 OK
   Content-Type: application/json;charset=UTF-8
   Cache-Control: no-store

   {
      "challenge_type": "oob",
      "oob_code": "GmRhmhcxhwAzkoEqiMEg_DnyEysNkuNhszIySk9eS",
      "binding_method": "prompt",
      "expires_in": 300,
      "interval": 5
   }

6.2.3.  Recovery Code Challenge

   If the authorization server requires a recovery code as an
   authorization grant, it responds with a recovery code authorization
   challenge containing the following parameters:

   "challenge_type":  REQUIRED.  Value MUST be set to recovery-code.

   No additional parameters are specified for the recovery code
   authorization challenge type.

   For example:

   HTTP/1.1 200 OK
   Content-Type: application/json;charset=UTF-8
   Cache-Control: no-store
   Pragma: no-cache

   {
     "challenge_type": "recovery-code"
   }

   TODO: It is unclear why the AS would decide a recovery code is
   required, since that assumes the AS knows the user has lost their
   other MFA options.

6.3.  User Interaction

6.3.1.  OTP Challenge Interaction

   After receiving an OTP challenge, the client prompts or otherwise
   interacts with the resource owner to obtain an OTP generated by a
   device in the possession of the resource owner.

6.3.2.  OOB Challenge Interaction

   After receiving an out-of-band challenge, the client prompts or
   otherwise interacts with the resource owner to inform them of the
   ongoing authorization operation.  Any necessary actions by the
   resource owner or other party on the secondary channel are out of
   scope of this specification.

   For example, the client informs the user to expect to receive a
   verification code via SMS, and provides a form to enter the code.

6.3.3.  Recovery Code Challenge Interaction

   After receiving a recovery code challenge, the client prompts or
   otherwise interacts with the resource owner to obtain a recovery
   code.  Such codes are typically already in the resource owner's
   posession, having been previously distributed to the resource owner.

   Recovery codes are typically necessary upon the resource owner
   realizing that other authenticators have been lost or are
   malfunctioning (for instance, when attempting to satisfy a non-
   recovery code authorization challenge).  In such an event, the client
   SHOULD provide the resource owner a means of directly entering a
   recovery flow.

7.  Token Request Grant Types

   This specification defines new grant types at the token endpoint,
   providing a way for a client to obtain an access token given any of
   the MFA challenges previously described.

7.1.  OTP Grant

   The client makes a request to the token endpoint by adding the
   following parameters using the "application/x-www-form-urlencoded"
   format with a character encoding of UTF-8 in the HTTP request body:

   "grant_type":  REQUIRED. urn:ietf:params:oauth:grant-type:mfa-otp

   "otp":  REQUIRED.  The one-time password generated by a device. e.g.
      123456

   "mfa_token":  REQUIRED.  The MFA token, "mfa_token" from the prior
      authorization challenge error response

   "client_id":  REQUIRED if the client is not authenticating with the
      authorization server.

   For example:

   POST /token HTTP/1.1
   Host: server.example.com
   Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
   Content-Type: application/x-www-form-urlencoded

   grant_type=urn:ietf:params:oauth:grant-type:mfa-otp
   &otp=123456&mfa_token=uY29tL2F1dGhlbnRpY

   The authorization server MUST:

   *  require client authentication for confidential clients or for any
      client that was issued client credentials (or with other
      authentication requirements),

   *  authenticate the client if client authentication is included,

   *  ensure that the MFA token was issued to the authenticated
      confidential client, or if the client is public, ensure that the
      token was issued to client_id in the request,

   *  verify that the MFA token is valid,

   *  restore the authorization session based on the state referenced by
      or encoded into the MFA token, and

   *  validate the one-time password credentials using its existing OTP
      validation algorithm.

7.2.  OOB Grant

   The client makes a request to the token endpoint by adding the
   following parameters using the "application/x-www-form-urlencoded"
   format with a character encoding of UTF-8 in the HTTP request body:

   "grant_type":  REQUIRED. urn:ietf:params:oauth:grant-type:mfa-oob

   "oob_code":  REQUIRED.  The out-of-band transaction code, oob_code
      from the authorization challenge, defined in Section 6.2.2

   "binding_code":  REQUIRED, if the binding method of the authorization
      challenge is set to "prompt".

   "mfa_token":  REQUIRED.  The MFA token, "mfa_token" from the prior
      authorization challenge error response, defined in Section 5.

   "client_id":  REQUIRED, if the client is not authenticating with the
      authorization server as described in Section 3.2.1 of OAuth 2.0
      [RFC6749].

   If the client type is confidential or the client was issued client
   credentials (or assigned other authentication requirements), the
   client MUST authenticate with the authorization server as described
   in Section 3.2.1 of OAuth 2.0 [RFC6749].

   For example, the client makes the following HTTP request using
   transport-layer security (with extra line breaks for display purposes
   only):

   POST /token HTTP/1.1
   Host: server.example.com
   Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
   Content-Type: application/x-www-form-urlencoded

   grant_type=urn:ietf:params:oauth:grant-type:mfa-oob
   &oob_code=GmRhmhcxhwAzkoEqiMEg_DnyEysNkuNhszIySk9eS
   &binding_code=123456&mfa_token=uY29tL2F1dGhlbnRpY

   The authorization server MUST:

   *  require client authentication for confidential clients or for any
      client that was issued client credentials (or with other
      authentication requirements),

   *  authenticate the client if client authentication is included,

   *  ensure that the MFA token was issued to the authenticated
      confidential client, or if the client is public, ensure that the
      token was issued to client_id in the request,

   *  verify that the MFA token is valid,

   *  restore the authorization session based on the state referenced by
      or encoded into the MFA token,

   *  validate the out-of-band transaction code using its existing OOB
      validation algorithm, and

   *  if required, validate the binding code using its existing OOB
      validation algorithm.

7.2.1.  Token Error Response

   In addition to the error codes defined in Section 5.2 of OAuth 2.0
   [RFC6749], the following error codes are specific for the out-of-band
   authorization grant in token endpoint responses:

   "authorization_pending":  The authorization request is still pending
      as the out-of-band authorization operation has not yet completed.
      The client SHOULD repeat the access token request to the token
      endpoint (a process known as polling).  Before each new request,
      the client MUST wait at least the number of seconds specified by
      the interval parameter of the authorization challenge (see
      Section X), or 5 seconds if none was provided, and respect any
      increase in the polling interval required by the slow_down error.

   "slow_down":  A variant of "authorization_pending", the authorization
      request is still pending and polling should continue, but the
      interval MUST be increased by 5 seconds for this and all
      subsequent requests.

   "access_denied":  The authorization request was denied.

   "expired_token":  The "oob_code" or "mfa_token" has expired, and the
      authorization session has concluded.  The client MAY commence a
      new authorization session but SHOULD wait for user interaction
      before restarting to avoid unnecessary polling.

   The authorization_pending and slow_down error codes define
   particularly unique behavior, as they indicate that the OAuth client
   should continue to poll the token endpoint by repeating the token
   request (implementing the precise behavior defined above).  If the
   client receives an error response with any other error code, it MUST
   stop polling and SHOULD react accordingly, for example, by displaying
   an error to the user.

   On encountering a connection timeout, clients MUST unilaterally
   reduce their polling frequency before retrying.  The use of an
   exponential backoff algorithm to achieve this, such as doubling the
   polling interval on each such connection timeout, is RECOMMENDED.

   The error codes and client behavior specified in this section are
   intentionally identical to those defined by OAuth 2.0 Device
   Authorization Grant [RFC8628].

7.3.  Recovery Code Grant

   The client makes a request to the token endpoint by adding the
   following parameters using the "application/x-www-form-urlencoded"
   format with a character encoding of UTF-8 in the HTTP request body:

   "grant_type":  REQUIRED.  urn:ietf:params:oauth:grant-type:mfa-
      recovery-code

   "recovery_code":  REQUIRED.  The recovery code.

   "mfa_token":  REQUIRED.  The MFA token, "mfa_token" from the prior
      authorization challenge error response, defined in Section 5.

   "client_id":  REQUIRED, if the client is not authenticating with the
      authorization server as described in Section 3.2.1 of OAuth 2.0
      [RFC6749].

   If the client type is confidential or the client was issued client
   credentials (or assigned other authentication requirements), the
   client MUST authenticate with the authorization server as described
   in Section 3.2.1 of OAuth 2.0 [RFC6749].

   For example, the client makes the following HTTP request using
   transport-layer security (with extra line breaks for display purposes
   only):

   POST /token HTTP/1.1
   Host: server.example.com
   Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
   Content-Type: application/x-www-form-urlencoded

   grant_type=urn:ietf:params:oauth:grant-type:mfa-recovery-code
   &recovery_code=WDJB-MJHT&mfa_token=uY29tL2F1dGhlbnRpY

   The authorization server MUST:

   *  require client authentication for confidential clients or for any
      client that was issued client credentials (or with other
      authentication requirements),

   *  authenticate the client if client authentication is included,

   *  ensure that the MFA token was issued to the authenticated
      confidential client, or if the client is public, ensure that the
      token was issued to client_id in the request,

   *  verify that the MFA token is valid,

   *  restore the authorization session based on the state referenced by
      or encoded into the MFA token, and

   *  validate the recovery code using its existing recovery code
      validation algorithm.

7.3.1.  Access Token Response

   In addition to the parameters defined in Section 5.1 of OAuth 2.0
   [RFC6749], the following additional parameters are specified for the
   recovery code grant:

   "recovery_code":  OPTIONAL.  A newly issued recovery code, in which
      case the client MUST discard the old recovery code and replace it
      with the new recovery code.

   TODO: Do most systems currently give the user new recovery codes
   during this flow?


   Old stuff below

8.  Examples

8.1.  Client receives trigger for authentication

   TODO: The client may receive a trigger from the resource server to
   initiate an authentication, possibly with a hint from the resource
   server in the form of an acr value, indicating it needs to initiate
   and authentications.

   TBD: May need to reference the existing step-up authentication draft
   instead

8.2.  Client collects user identifier

   TODO: User identifier can be an email, phone number, or username, at
   the discretion of the AS.

8.3.  Client initiates direct interaction request

   The client makes a request to the interaction request endpoint
   providing the client ID and user identifer hint in the request.

   POST /interaction
   Host: authorization-server.com
   Content-type: application/x-www-form-urlencoded

   &client_id=XXXXXXX
   &username=user@example.com
   &scope=contacts+openid+profile

8.4.  Authorization Server returns challenge types

   The AS returns an interaction code, as well as a list of challenge
   types supported.

   HTTP/1.1 403 Forbidden
   Content-type: application/json

   {
     "error": "...?",
     "interaction_code": "b135ac938e3e84",
     "challenge_type": [
       "password+totp", "email_otp", "redirect"
     ]
   }

8.4.1.  One-Time code

   *  email_otp

   *  sms_otp

   One-time codes sent via email or SMS

8.4.2.  TOTP

   *  totp

   TOTP codes generated by an authenticator app

8.4.3.  Password

   *  password

   Legacy password authentication

8.4.4.  Push notification

   *  push_notification

   A push notification delivered to a native application

8.4.5.  Redirect

   *  redirect

   In the case where the authorization server wishes to interact with
   the user itself, limiting the client's interaction with the user, it
   can return the redirect challenge type.  In this case, no
   interaction_code is returned.  Instead, the client is expected to
   initiate a traditional OAuth Authorization Code flow with PKCE
   according to [RFC6749] and [RFC7636].

   TODO: Instead of no interaction code, should this require the client
   include the interaction code in the authorization request so the AS
   can link it to an app-initiated session?  Alternatively, if we make
   the first request require a PKCE code challenge, we could require the
   same PKCE code challenge be used in the authorization request.  My
   preference here is to include the PKCE code verifier at the start of
   the protocol.  PKCE is well understood and re-using the interaction
   code to establish the link feels like we are overloading the
   interaction code.  Another option may be to add a session identifier
   (or return a session identifier as a unique parameter) for the
   redirect case.

   This can be used to:

   *  offer the client a fallback mechanism at the client's perogative
      (by returning the redirect type as the last item in the
      challenge_type list)

   *  force the client to use a browser-redirect-based flow (by
      returning only the redirect type)

   *  enable authentication with social providers or third party IdPs
      which require a browser flow

8.4.6.  Combinations

   The AS MAY combine challenge types by concatenating strings with a +,
   which indicates that all the combined types are required to complete
   the challenge.

   TODO: Does the absense of a '+' imply an OR?

8.4.7.  Defining additional methods

   Extensibility...

8.5.  Client requests an authentication challenge

   Optional.

   For methods that require the AS to deliver a code to the user, e.g.
   via email or SMS, the client needs to signal to the AS that it should
   deliver this code.  (Without this step, the AS may not know which of
   the available options the client will be communicating to the user,
   and may not want to send a code via both email and SMS.).  It SHOULD
   only allow one delivery mechanism at a time to minimise the risk of
   the challenge leaking.

   POST /challenge
   Host: authorization-server.com
   Content-type: application/x-www-form-urlencoded

   challenge_type=email_otp
   &interaction_code=b135ac938e3e84

   The authorization server sends a challenge code to the user via the
   selected platform.

   The authorization server responds with an authentication challenge
   code and other information such as timeouts.

   HTTP/1.1 200 OK
   Content-type: application/json

   {
     "challenge_type": "email_otp",
     "challenge_code": "a6f4463ad1d8e3f",
     "expires_in": 600,
     "interval": 5
   }

   *  challenge_type -

   *  challenge_code -

   *  expires_in - Optional

   *  interval - Optional

8.6.  Client provides authentication details

   The client prompts the user to enter the challenge.

   *  One-time code

   *  Password

   *  Out-of-band interaction

   Some methods such as acknowledging a push notification may not
   require the user to interact further with the client.  The client
   instead presents a screen to the user explaining that they should
   acknowledge the challenge on another device.

   TODO: How does the Authorisation Server signal to the client that the
   push notification succeeded on another device?

8.6.1.  Token request

   The client makes a request to the token endpoint with the grant_type
   value of urn:ietf:params:oauth:grant-type:direct, providing the
   information collected from the user as well as the previous
   interaction code and optional challenge code.

   POST /token

   Host: authorization-server.com
   Content-type: application/x-www-form-urlencoded

   grant_type=urn:ietf:params:oauth:grant-type:direct
   &client_id=XXXXXXX
   &interaction_code=b135ac938e3e84
   &challenge_code=a6f4463ad1d8e3f
   &challenge_value=512512

   *  challenge_value - The value that was sent to the user.  Should
      this be different depending on the challenge type?

   TODO: What happens if more than one code is requested?  Maybe make it
   so only one can be collected at a time?  It would be weird to ask the
   user to enter two codes at the same time anyway.  Not sure we should
   have a unique interaction code per token.  Should the interaction
   code cover all the interactions (i.e. all interactions are bundled up
   as one interaction).  Once all interactions are complete all tokens
   for which that interaction is good can be released?

8.7.  Checking for additional requirements

   If the initial set of information provided by the client is correct,
   the AS MAY choose to either respond immediately with a successful
   token response, or prompt the client for an additional challenge.

   For example, the AS could first require the client prompt the user
   for a one-time-code they received via email, and then in a second
   step, ask the client to prompt the user

9.  Refresh Token Grant

   TODO: Describe how the AS could return a challenge to the client on
   the normal refresh token request that tells the client they need to
   get the user to re-authenticate or provide an MFA token.

10.  Security Considerations

   TODO Security

10.1.  Phishing

   TODO: Describe the phishing risk this opens up.

10.2.  Native client and Authorisation Server trust relationship

   TODO: Emphasise the 'same owner' relationship between the native
   client and the authorisation server

10.3.  Client Authentication

   TODO: Describe the lack of client authentication possible because
   this is expected to be deployed by native apps.  Maybe mention
   alternatives to client authentication such as App Attestation, or
   using a risk engine to analyze other aspects of the request from the
   client.

10.4.  Leaking Information

   TODO: Attackers may be able to query the AS with user IDs to learn
   whether an identifier corresponds to an active account and which
   types of authentication a particular account has configured.  What
   mitigations needed here?  Possibly avoiding returning an error for
   unrecognized identifiers.

10.5.  Notification fatigue

   TODO: A client may be able to cause repeated notifications to any
   user given their user ID.

   Mitigations:

   *  rate limiting

   *  use notification-based methods only as a secondary factor

11.  IANA Considerations

11.1.  OAuth Parameter Registration

   TODO

11.2.  OAuth URI Registration

   This specification registers the following values in the IANA "OAuth
   URI" registry (IANA.OAuth.Parameters) established by [RFC6755].

   URN: `urn:ietf:params:oauth:grant-type:direct`
   Common Name: Direct Interaction Grant Type for OAuth 2.0
   Change Controller: IESG
   Specification Document:

11.3.  OAuth Extensions Error Registration

   This specification registers the following values in the IANA "OAuth
   Extensions Error Registry" registry (IANA.OAuth.Parameters)
   established by [RFC6749].

   Name: ...

11.4.  Authorization Server Metadata

   This specification defines two new endpoints at the authorization
   server.  TODO: Need to register these in the Authorization Server
   Metadata document too.

   *  interaction endpoint

   *  challenge endpoint

12.  References

12.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              <https://www.rfc-editor.org/rfc/rfc6749>.

   [RFC6755]  Campbell, B. and H. Tschofenig, "An IETF URN Sub-Namespace
              for OAuth", RFC 6755, DOI 10.17487/RFC6755, October 2012,
              <https://www.rfc-editor.org/rfc/rfc6755>.

   [RFC7636]  Sakimura, N., Ed., Bradley, J., and N. Agarwal, "Proof Key
              for Code Exchange by OAuth Public Clients", RFC 7636,
              DOI 10.17487/RFC7636, September 2015,
              <https://www.rfc-editor.org/rfc/rfc7636>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8259]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, RFC 8259,
              DOI 10.17487/RFC8259, December 2017,
              <https://www.rfc-editor.org/rfc/rfc8259>.

12.2.  Informative References

   [RFC8628]  Denniss, W., Bradley, J., Jones, M., and H. Tschofenig,
              "OAuth 2.0 Device Authorization Grant", RFC 8628,
              DOI 10.17487/RFC8628, August 2019,
              <https://www.rfc-editor.org/rfc/rfc8628>.

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Aaron Parecki
   Okta
   Email: aaron@parecki.com


   Pieter Kasselman
   Microsoft
   Email: pieter.kasselman@microsoft.com
